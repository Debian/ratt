// Code generated by protoc-gen-go. DO NOT EDIT.
// source: build.proto

/*
Package pb is a generated protocol buffer package.

It is generated from these files:
	build.proto
	semaphore.proto
	config.proto

It has these top-level messages:
	StartRequest
	StartReply
	WaitRequest
	WaitReply
	WriteFileChunk
	WriteFileReply
	TarRequest
	TarChunk
	CleanRequest
	CleanReply
	AcquireRequest
	AcquireReply
	ReleaseRequest
	ReleaseReply
	GetRequest
	GetReply
*/
package pb

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type StartRequest struct {
	BuildId string `protobuf:"bytes,1,opt,name=build_id,json=buildId" json:"build_id,omitempty"`
	// Debian distribution (e.g. sid) to build for. Defaults to sid if empty.
	Distribution string `protobuf:"bytes,2,opt,name=distribution" json:"distribution,omitempty"`
	// Source package to build, in the form “package_version”.
	Package string `protobuf:"bytes,3,opt,name=package" json:"package,omitempty"`
	// Path names of extra .deb files to install when building. The path is
	// relative to the build directory, i.e. files must have been created using
	// WriteFile beforehand.
	ExtraPackage []string `protobuf:"bytes,4,rep,name=extra_package,json=extraPackage" json:"extra_package,omitempty"`
}

func (m *StartRequest) Reset()                    { *m = StartRequest{} }
func (m *StartRequest) String() string            { return proto.CompactTextString(m) }
func (*StartRequest) ProtoMessage()               {}
func (*StartRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *StartRequest) GetBuildId() string {
	if m != nil {
		return m.BuildId
	}
	return ""
}

func (m *StartRequest) GetDistribution() string {
	if m != nil {
		return m.Distribution
	}
	return ""
}

func (m *StartRequest) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *StartRequest) GetExtraPackage() []string {
	if m != nil {
		return m.ExtraPackage
	}
	return nil
}

type StartReply struct {
}

func (m *StartReply) Reset()                    { *m = StartReply{} }
func (m *StartReply) String() string            { return proto.CompactTextString(m) }
func (*StartReply) ProtoMessage()               {}
func (*StartReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type WaitRequest struct {
	BuildId string `protobuf:"bytes,1,opt,name=build_id,json=buildId" json:"build_id,omitempty"`
}

func (m *WaitRequest) Reset()                    { *m = WaitRequest{} }
func (m *WaitRequest) String() string            { return proto.CompactTextString(m) }
func (*WaitRequest) ProtoMessage()               {}
func (*WaitRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *WaitRequest) GetBuildId() string {
	if m != nil {
		return m.BuildId
	}
	return ""
}

type WaitReply struct {
	// exit_status is the exit status of sbuild(1).
	ExitStatus uint32 `protobuf:"varint,1,opt,name=exit_status,json=exitStatus" json:"exit_status,omitempty"`
}

func (m *WaitReply) Reset()                    { *m = WaitReply{} }
func (m *WaitReply) String() string            { return proto.CompactTextString(m) }
func (*WaitReply) ProtoMessage()               {}
func (*WaitReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *WaitReply) GetExitStatus() uint32 {
	if m != nil {
		return m.ExitStatus
	}
	return 0
}

type WriteFileChunk struct {
	BuildId string `protobuf:"bytes,1,opt,name=build_id,json=buildId" json:"build_id,omitempty"`
	// filename is only used on the first chunk and must not be set in any other
	// chunk. To write different files, call WriteFile once per file.
	Filename string `protobuf:"bytes,2,opt,name=filename" json:"filename,omitempty"`
	Data     []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *WriteFileChunk) Reset()                    { *m = WriteFileChunk{} }
func (m *WriteFileChunk) String() string            { return proto.CompactTextString(m) }
func (*WriteFileChunk) ProtoMessage()               {}
func (*WriteFileChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *WriteFileChunk) GetBuildId() string {
	if m != nil {
		return m.BuildId
	}
	return ""
}

func (m *WriteFileChunk) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *WriteFileChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type WriteFileReply struct {
}

func (m *WriteFileReply) Reset()                    { *m = WriteFileReply{} }
func (m *WriteFileReply) String() string            { return proto.CompactTextString(m) }
func (*WriteFileReply) ProtoMessage()               {}
func (*WriteFileReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type TarRequest struct {
	BuildId string `protobuf:"bytes,1,opt,name=build_id,json=buildId" json:"build_id,omitempty"`
}

func (m *TarRequest) Reset()                    { *m = TarRequest{} }
func (m *TarRequest) String() string            { return proto.CompactTextString(m) }
func (*TarRequest) ProtoMessage()               {}
func (*TarRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *TarRequest) GetBuildId() string {
	if m != nil {
		return m.BuildId
	}
	return ""
}

type TarChunk struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *TarChunk) Reset()                    { *m = TarChunk{} }
func (m *TarChunk) String() string            { return proto.CompactTextString(m) }
func (*TarChunk) ProtoMessage()               {}
func (*TarChunk) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *TarChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type CleanRequest struct {
	BuildId string `protobuf:"bytes,1,opt,name=build_id,json=buildId" json:"build_id,omitempty"`
	// spare_filenames are not cleaned up, under the assumption that the next
	// build will need them, too.
	SpareFilename []string `protobuf:"bytes,2,rep,name=spare_filename,json=spareFilename" json:"spare_filename,omitempty"`
}

func (m *CleanRequest) Reset()                    { *m = CleanRequest{} }
func (m *CleanRequest) String() string            { return proto.CompactTextString(m) }
func (*CleanRequest) ProtoMessage()               {}
func (*CleanRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *CleanRequest) GetBuildId() string {
	if m != nil {
		return m.BuildId
	}
	return ""
}

func (m *CleanRequest) GetSpareFilename() []string {
	if m != nil {
		return m.SpareFilename
	}
	return nil
}

type CleanReply struct {
}

func (m *CleanReply) Reset()                    { *m = CleanReply{} }
func (m *CleanReply) String() string            { return proto.CompactTextString(m) }
func (*CleanReply) ProtoMessage()               {}
func (*CleanReply) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func init() {
	proto.RegisterType((*StartRequest)(nil), "pb.StartRequest")
	proto.RegisterType((*StartReply)(nil), "pb.StartReply")
	proto.RegisterType((*WaitRequest)(nil), "pb.WaitRequest")
	proto.RegisterType((*WaitReply)(nil), "pb.WaitReply")
	proto.RegisterType((*WriteFileChunk)(nil), "pb.WriteFileChunk")
	proto.RegisterType((*WriteFileReply)(nil), "pb.WriteFileReply")
	proto.RegisterType((*TarRequest)(nil), "pb.TarRequest")
	proto.RegisterType((*TarChunk)(nil), "pb.TarChunk")
	proto.RegisterType((*CleanRequest)(nil), "pb.CleanRequest")
	proto.RegisterType((*CleanReply)(nil), "pb.CleanReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Build service

type BuildClient interface {
	// WriteFile persists a stream of chunks into a file. Typically used for
	// transferring extra packages.
	WriteFile(ctx context.Context, opts ...grpc.CallOption) (Build_WriteFileClient, error)
	// Start starts the package build. Returns as soon as the build was started,
	// so call Wait right after. This design allows us to distinguish between
	// in-progress builds and pending build requests on the client side.
	Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartReply, error)
	// Wait blocks until the build finished.
	Wait(ctx context.Context, in *WaitRequest, opts ...grpc.CallOption) (*WaitReply, error)
	// Tar returns a tar archive of the build directory.
	Tar(ctx context.Context, in *TarRequest, opts ...grpc.CallOption) (Build_TarClient, error)
	// Clean empties the build directory (files useful for the next build can be
	// spared) and removes it once no files are left.
	Clean(ctx context.Context, in *CleanRequest, opts ...grpc.CallOption) (*CleanReply, error)
}

type buildClient struct {
	cc *grpc.ClientConn
}

func NewBuildClient(cc *grpc.ClientConn) BuildClient {
	return &buildClient{cc}
}

func (c *buildClient) WriteFile(ctx context.Context, opts ...grpc.CallOption) (Build_WriteFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Build_serviceDesc.Streams[0], c.cc, "/pb.Build/WriteFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &buildWriteFileClient{stream}
	return x, nil
}

type Build_WriteFileClient interface {
	Send(*WriteFileChunk) error
	CloseAndRecv() (*WriteFileReply, error)
	grpc.ClientStream
}

type buildWriteFileClient struct {
	grpc.ClientStream
}

func (x *buildWriteFileClient) Send(m *WriteFileChunk) error {
	return x.ClientStream.SendMsg(m)
}

func (x *buildWriteFileClient) CloseAndRecv() (*WriteFileReply, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(WriteFileReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *buildClient) Start(ctx context.Context, in *StartRequest, opts ...grpc.CallOption) (*StartReply, error) {
	out := new(StartReply)
	err := grpc.Invoke(ctx, "/pb.Build/Start", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildClient) Wait(ctx context.Context, in *WaitRequest, opts ...grpc.CallOption) (*WaitReply, error) {
	out := new(WaitReply)
	err := grpc.Invoke(ctx, "/pb.Build/Wait", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildClient) Tar(ctx context.Context, in *TarRequest, opts ...grpc.CallOption) (Build_TarClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Build_serviceDesc.Streams[1], c.cc, "/pb.Build/Tar", opts...)
	if err != nil {
		return nil, err
	}
	x := &buildTarClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Build_TarClient interface {
	Recv() (*TarChunk, error)
	grpc.ClientStream
}

type buildTarClient struct {
	grpc.ClientStream
}

func (x *buildTarClient) Recv() (*TarChunk, error) {
	m := new(TarChunk)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *buildClient) Clean(ctx context.Context, in *CleanRequest, opts ...grpc.CallOption) (*CleanReply, error) {
	out := new(CleanReply)
	err := grpc.Invoke(ctx, "/pb.Build/Clean", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Build service

type BuildServer interface {
	// WriteFile persists a stream of chunks into a file. Typically used for
	// transferring extra packages.
	WriteFile(Build_WriteFileServer) error
	// Start starts the package build. Returns as soon as the build was started,
	// so call Wait right after. This design allows us to distinguish between
	// in-progress builds and pending build requests on the client side.
	Start(context.Context, *StartRequest) (*StartReply, error)
	// Wait blocks until the build finished.
	Wait(context.Context, *WaitRequest) (*WaitReply, error)
	// Tar returns a tar archive of the build directory.
	Tar(*TarRequest, Build_TarServer) error
	// Clean empties the build directory (files useful for the next build can be
	// spared) and removes it once no files are left.
	Clean(context.Context, *CleanRequest) (*CleanReply, error)
}

func RegisterBuildServer(s *grpc.Server, srv BuildServer) {
	s.RegisterService(&_Build_serviceDesc, srv)
}

func _Build_WriteFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BuildServer).WriteFile(&buildWriteFileServer{stream})
}

type Build_WriteFileServer interface {
	SendAndClose(*WriteFileReply) error
	Recv() (*WriteFileChunk, error)
	grpc.ServerStream
}

type buildWriteFileServer struct {
	grpc.ServerStream
}

func (x *buildWriteFileServer) SendAndClose(m *WriteFileReply) error {
	return x.ServerStream.SendMsg(m)
}

func (x *buildWriteFileServer) Recv() (*WriteFileChunk, error) {
	m := new(WriteFileChunk)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Build_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Build/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildServer).Start(ctx, req.(*StartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Build_Wait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildServer).Wait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Build/Wait",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildServer).Wait(ctx, req.(*WaitRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Build_Tar_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TarRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BuildServer).Tar(m, &buildTarServer{stream})
}

type Build_TarServer interface {
	Send(*TarChunk) error
	grpc.ServerStream
}

type buildTarServer struct {
	grpc.ServerStream
}

func (x *buildTarServer) Send(m *TarChunk) error {
	return x.ServerStream.SendMsg(m)
}

func _Build_Clean_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CleanRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildServer).Clean(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Build/Clean",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildServer).Clean(ctx, req.(*CleanRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Build_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Build",
	HandlerType: (*BuildServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Start",
			Handler:    _Build_Start_Handler,
		},
		{
			MethodName: "Wait",
			Handler:    _Build_Wait_Handler,
		},
		{
			MethodName: "Clean",
			Handler:    _Build_Clean_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WriteFile",
			Handler:       _Build_WriteFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "Tar",
			Handler:       _Build_Tar_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "build.proto",
}

func init() { proto.RegisterFile("build.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 390 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x53, 0x4d, 0x8f, 0xda, 0x30,
	0x10, 0x25, 0x7c, 0x14, 0x18, 0x12, 0x8a, 0xe6, 0x94, 0xe6, 0xd0, 0x22, 0x57, 0x15, 0x91, 0x5a,
	0xa1, 0xaa, 0x3d, 0xf4, 0x5e, 0x24, 0xa4, 0xde, 0x50, 0x40, 0xe2, 0xd0, 0x43, 0xe4, 0x34, 0x6e,
	0x6b, 0x91, 0x0d, 0x5e, 0xc7, 0x91, 0xe0, 0x3f, 0xec, 0x5f, 0xdd, 0xff, 0xb0, 0xca, 0x38, 0x90,
	0x70, 0x59, 0x71, 0xcb, 0x3c, 0x3f, 0xbf, 0x99, 0xf7, 0x26, 0x86, 0x49, 0x52, 0xca, 0x2c, 0x5d,
	0x2a, 0x7d, 0x34, 0x47, 0xec, 0xaa, 0x84, 0x3d, 0x39, 0xe0, 0x6e, 0x0d, 0xd7, 0x26, 0x12, 0x8f,
	0xa5, 0x28, 0x0c, 0xbe, 0x83, 0x11, 0x71, 0x62, 0x99, 0xfa, 0xce, 0xdc, 0x09, 0xc7, 0xd1, 0x90,
	0xea, 0x5f, 0x29, 0x32, 0x70, 0x53, 0x59, 0x18, 0x2d, 0x93, 0xd2, 0xc8, 0x63, 0xee, 0x77, 0xe9,
	0xf8, 0x06, 0x43, 0x1f, 0x86, 0x8a, 0xff, 0x39, 0xf0, 0x7f, 0xc2, 0xef, 0xd9, 0xdb, 0x75, 0x89,
	0x1f, 0xc1, 0x13, 0x27, 0xa3, 0x79, 0x7c, 0x39, 0xef, 0xcf, 0x7b, 0xd5, 0x75, 0x02, 0x37, 0x16,
	0x63, 0x2e, 0x40, 0x3d, 0x8d, 0xca, 0xce, 0x2c, 0x84, 0xc9, 0x9e, 0xcb, 0x3b, 0x46, 0x63, 0x5f,
	0x60, 0x6c, 0x99, 0x2a, 0x3b, 0xe3, 0x07, 0x98, 0x88, 0x93, 0x34, 0x71, 0x61, 0xb8, 0x29, 0x0b,
	0xa2, 0x7a, 0x11, 0x54, 0xd0, 0x96, 0x10, 0xf6, 0x1b, 0xa6, 0x7b, 0x2d, 0x8d, 0x58, 0xcb, 0x4c,
	0xac, 0xfe, 0x97, 0xf9, 0xe1, 0x35, 0xd7, 0x01, 0x8c, 0xfe, 0xca, 0x4c, 0xe4, 0xfc, 0x41, 0xd4,
	0x8e, 0xaf, 0x35, 0x22, 0xf4, 0x53, 0x6e, 0x38, 0x59, 0x75, 0x23, 0xfa, 0x66, 0xb3, 0x96, 0xb8,
	0xb5, 0xb1, 0x00, 0xd8, 0x71, 0x7d, 0x87, 0x8b, 0xf7, 0x30, 0xda, 0x71, 0x6d, 0x27, 0xba, 0x48,
	0x3b, 0x2d, 0xe9, 0x0d, 0xb8, 0xab, 0x4c, 0xf0, 0xfc, 0x8e, 0x5d, 0x7d, 0x82, 0x69, 0xa1, 0xb8,
	0x16, 0x71, 0x6b, 0xf6, 0x2a, 0x6e, 0x8f, 0xd0, 0x75, 0x0d, 0x56, 0x79, 0xd7, 0x8a, 0x2a, 0x3b,
	0x7f, 0x7b, 0x76, 0x60, 0xf0, 0xb3, 0x12, 0xc0, 0x1f, 0x30, 0xbe, 0x9a, 0x40, 0x5c, 0xaa, 0x64,
	0x79, 0x1b, 0x58, 0x70, 0x8b, 0x59, 0x9f, 0x9d, 0xd0, 0xc1, 0xcf, 0x30, 0xa0, 0x05, 0xe2, 0xac,
	0x22, 0xb4, 0xff, 0xac, 0x60, 0xda, 0x42, 0x88, 0x8e, 0x21, 0xf4, 0xab, 0xad, 0xe1, 0x5b, 0x12,
	0x6b, 0x36, 0x1d, 0x78, 0x0d, 0x60, 0x99, 0x0b, 0xe8, 0xed, 0xb8, 0x46, 0x92, 0x68, 0xb2, 0x0c,
	0xdc, 0xba, 0xa6, 0x99, 0x58, 0xe7, 0x2b, 0xf5, 0x27, 0x43, 0xb6, 0x7f, 0x3b, 0x2d, 0xdb, 0xbf,
	0x71, 0xcb, 0x3a, 0xc9, 0x1b, 0x7a, 0x07, 0xdf, 0x5f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x48, 0xe6,
	0x38, 0xb2, 0x16, 0x03, 0x00, 0x00,
}
